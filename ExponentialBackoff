Exponential backoff is a technique that involves increasing the time between retries
exponentially as the number of retries increases. This approach helps to reduce
the load on the server by spacing out the retries, rather than sending a flood of
requests all at once. For example, if the initial retry delay is 1 second and the
backoff factor is 2, then the second retry would be delayed by 2 seconds, the
third by 4 seconds, the fourth by 8 seconds, and so on. This gives the server
time to recover from any overload or connectivity issues before being hit with
another flood of requests.

Jitter is a technique that adds randomness to the retry interval to prevent all
clients from retrying at the same time. Without jitter, all clients might retry
at the same time, leading to another surge of requests hitting the server at the
same time. Jitter adds a random factor to the retry delay, which spreads out the
retry attempts over time. For example, if the calculated retry delay is 5 seconds
and the jitter factor is 0.2, then the actual retry delay might be anywhere
between 4 and 6 seconds, chosen randomly. This helps to reduce the chances of
all clients retrying at the same time.

I'm using Ktor here instead of an alternative library like Retrofit or okhttp3.
Ktor is a lightweight, Kotlin-first HTTP client and server framework that is designed
to be easy to use and extend. It has built-in support for coroutine-based
concurrency, JSON serialization, websockets, and more

Here's an example implementation:


import com.fasterxml.jackson.databind.ObjectMapper
import io.ktor.client.*
import io.ktor.client.engine.cio.*
import io.ktor.client.features.*
import io.ktor.client.features.json.*
import io.ktor.client.request.*
import kotlinx.coroutines.delay
import kotlin.math.pow
import kotlin.random.Random

class Client(private val baseUrl: String) {
    private val objectMapper = ObjectMapper()
    private val client = HttpClient(CIO) {
        install(JsonFeature)
    }
    private val maxRetries = 5
    private val initialDelayMillis = 1000L
    private val maxDelayMillis = 30000L
    private val jitterFactor = 0.2

    suspend fun sendMessage(message: Any) {
        val json = objectMapper.writeValueAsString(message)
        val response = client.post<String>("$baseUrl/message") {
            contentType(io.ktor.http.ContentType.Application.Json)
            body = json
        }

        var retryCount = 0
        var delayMillis = initialDelayMillis
        while (true) {
            if (response.isSuccess()) {
                // message sent successfully
                break
            }

            retryCount++
            if (retryCount > maxRetries) {
                // too many retries, give up
                break
            }

            // calculate the next retry delay using exponential backoff with jitter
            val backoffMillis = (delayMillis * 2.0.pow(retryCount.toDouble()) * (1.0 + Random.nextDouble(-jitterFactor, jitterFactor))).toLong()
            delayMillis = kotlin.math.min(backoffMillis, maxDelayMillis)
            // wait for the calculated delay before retrying
            delay(delayMillis)
        }
    }
}

fun HttpResponse.isSuccess(): Boolean {
    return status.isSuccess() || status == io.ktor.http.HttpStatusCode.TooManyRequests
}
